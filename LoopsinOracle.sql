--PL/SQL exit loop is used when a set of statements is to be executed at least once before the termination of the loop.
--SET SERVEROUTPUT ON;

--DECLARE
--a number:=1;
--BEGIN
--LOOP
--EXIT WHEN a>10;
--dbms_output.put_line(a);
--a:=a+1;
--end LOOP;
--END;
--
----Second Method
--DECLARE
--b NUMBER:=10;
--BEGIN
--LOOP
--    dbms_output.put_line(b);
--        if(b=20)then
--            EXIT; 
--        end if;
--    b:=b+1;
--end LOOP;
--END;
--
----While Loop Execute untill condition hold true
--DECLARE
--c NUMBER:=3;
--BEGIN
--  WHILE c<=22 LOOP
--      DBMS_OUTPUT.PUT_LINE (c);
--      c:=c+1;
--    END LOOP;
--END;
--
----For starting and Ending
--DECLARE
--i number;
--BEGIN
-- FOR i IN 1..10 LOOP
--       DBMS_OUTPUT.PUT_LINE('For Loop '||i);
--     END LOOP;
--END;

--Continue use for forces the next iteration of the loop to take place, skipping any codes in between.

--DECLARE
--NUM INTEGER:=1;
--BEGIN
--LOOP
--NUM:=NUM+1;
--IF NUM<=8 THEN
--    continue;
--END IF;
--DBMS_OUTPUT.put_line(NUM);
--EXIT WHEN NUM=10;
--END LOOP;
--END;

SET SERVEROUTPUT ON;
DECLARE
a INTEGER:=1;
BEGIN

<<JUMP>>
DBMS_OUTPUT.PUT_LINE('Jumping');
while a<=10 LOOP
a:=a+1;
if a=5 then
    GOTO jump;
end if;
DBMS_OUTPUT.PUT_LINE('While Loop- '||a);
END LOOP;
END;

--Prodedure it is reusable block of code for unit of statement.
create table employees
(
empid number,
empname varchar(200),
empSalary float
)
select * from employees;
insert into employees values(101,'James',65000);

create PROCEDURE emp_proc 
(empid in  NUMBER,
 empnm in varchar,
 empsal in float
) is
BEGIN
insert into employees values(empid,empnm,empsal);
END;


--call the procedure
BEGIN
emp_proc(102,'Arun',70000);
DBMS_OUTPUT.PUT_LINE('Value Inserted Successfully');
END;

--delete values from table using procedure
create procedure mydelproce
(ids IN NUMBER)
is
BEGIN
DELETE FROM employees where empid=ids;
END;

----Call the procedure
--BEGIN
--mydelproce(101);
--END;
--select * from employees;
--
----create procedure for update
--create procedure myupdateproce
--(ids IN NUMBER)
--is
--BEGIN
--update employees set empname='Gita',empsalary=58222 where empid=ids;
--END;
--
----Call The Procedure
--BEGIN
--myupdateproce(102);
--END;
--select * from employees;
--
------update by passing values
--create procedure myupdateproce2
--(ids IN NUMBER,
--name in varchar,
--salary in float)
--is
--BEGIN
--update employees set empname=name,empsalary=salary where empid=ids;
--END;
--
----Call The Procedure2
--BEGIN
--myupdateproce2(103,'James',985878);
--END;
--select * from employees;


-- The main difference between procedure and a function is, a function must always return a value, 
--and on the other hand a procedure may or may not return a value

--CREATE FUNCTION myfunction(num1 in number,num2 in number)
--return number
--is
--num3 number(10);
--BEGIN
--num3:=num1+num2;
--return num3;
--END;
--
-----call function
--DECLARE
--RESULT number(10);
--BEGIN
--result:=myfunction(50,60);
--dbms_output.put_line('Additon of two number'||result);
--END;

--Cursor---A cursor is used to referred to a program to fetch and process the rows returned by the 
--SQL statement, one at a time.
--There are two types of cursors:
--Implicit Cursors
--Explicit Cursors
--1)PL/SQL Implicit Cursors
--The implicit cursors are automatically generated by Oracle while an SQL statement is executed, if you -
--don't use an explicit cursor for the statement.
--These are created by default to process the statements when DML statements like INSERT, UPDATE, DELETE etc. 
--are executed.

create table employees
(
empid number,
empname varchar(200),
empSalary float
)
select * from employees;
insert into employees values(101,'James',65000);

--Implicit Cursor
DECLARE
rowCnt number(2);
BEGIN
update employees set empsalary=empsalary+5000;
if sql%NOTFOUND THEN
    DBMS_OUTPUT.PUT_LINE('Not Updated');
elsif sql%found then
    rowCnt:=sql%rowcount;
    DBMS_OUTPUT.PUT_LINE('Updated Row = '||rowCnt);
end if;
END;

--Explicit cursors are defined by programmers to gain more control over the context area. It is defined 
--in the declaration section of the PL/SQL block. It is created on a SELECT statement 
--which returns more than one row.

DECLARE
ids employees.empid%type;
ename employees.empname%type;
salary employees.empsalary%type;
cursor mycur is
select * from employees;
BEGIN
open mycur;
LOOP
  fetch mycur into ids,ename,salary;
EXIT WHEN mycur%notfound;
  dbms_output.put_line(ids||' '||ename||' '||salary);
end loop;
close mycur;
END;

-----------Exception----------------------------------------
--An error occurs during the program execution is called Exception in PL/SQL.

create table employees
(
empid number,
empname varchar(200),
empSalary float
)
select * from employees;
insert into employees values(101,'James',65000);

DECLARE
eid employees.empid%type:=109;
epname employees.empname%type;
epsalary employees.empsalary%type;
BEGIN
select empname,empsalary into epname,epsalary from employees where empid=eid;
dbms_output.put_line('Name'||epname);
dbms_output.put_line('Salary'||epsalary);
Exception
when no_data_found then
    dbms_output.put_line('Record Not Found');
END;

--Raise Exceptions
--In the case of any internal database error, exceptions are raised by the database server automatically. 
--But it can also be raised explicitly by programmer by using command RAISE.
create table employees
(
empid number,
empname varchar(200),
empSalary float
)
select * from employees;
insert into employees values(101,'James',65000);

DECLARE
ids employees.empid%type:=-1;
epname employees.empname%type;
epsalary employees.empsalary%type;
myException Exception;
BEGIN
if ids<0 then
    raise myException;
else
    select empid,empname,empsalary into ids,epname,epsalary  from employees where empid=ids;
    dbms_output.put_line(ids||epname||epsalary);
end if;
EXCEPTION
      WHEN myException THEN
         dbms_output.put_line('Value should be greater then Zero');
      when others then
      dbms_output.put_line('Value should be greater then Zero');
END;


--Trigger-----------
 --An SQL trigger is a database object that is associated with a table and automatically executes a set 
 --of SQL statements when a specific event occurs on that table. Triggers are used to enforce business 
 --rules, maintain data integrity, and automate certain actions within a database.
create table employees
(
empid number,
empname varchar(200),
empSalary float
)
select * from employees;
insert into employees values(101,'James',65000);

create table empBackup
(
empid number,
empname varchar(200),
empSalary float
)
select * from empBackup;

--Create Trigger
create or replace trigger mytrigger before
insert on employees for each row
begin
insert into empBackup(empid,empname,empSalary) values(:NEW.empid,:NEW.empname,:NEW.empSalary);
end;

--insert values
insert into employees values(104,'Ritu',55000);

--Create delete Trigger
create or replace trigger delTrigger before
delete on employees for each row
begin
delete from empBackup where empid=:old.empid;
dbms_output.put_line('Record Deleted');
end;

--run delete trigger
delete from employees where empid=104;

--update trigger

create or replace trigger updTrigger after
update on employees for each row
begin
update empBackup set empname=:new.empname where empid=:new.empid;
dbms_output.put_line('Record Updated');
end;

update employees set empname='Anita Singh' where empid=104; 




















